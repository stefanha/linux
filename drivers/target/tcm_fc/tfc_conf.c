/*******************************************************************************
 * Filename:  tcm_fc.c
 *
 * This file contains the configfs implementation for TCM_fc fabric node.
 * Based on tcm_loop_configfs.c
 *
 * Copyright (c) 2010 Cisco Systems, Inc.
 * Copyright (c) 2009 Rising Tide, Inc.
 * Copyright (c) 2009 Linux-iSCSI.org
 *
 * Copyright (c) 2009 Nicholas A. Bellinger <nab@linux-iscsi.org>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 ****************************************************************************/

#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/version.h>
#include <linux/utsrelease.h>
#include <linux/utsname.h>
#include <linux/init.h>
#include <linux/slab.h>
#include <linux/kthread.h>
#include <linux/types.h>
#include <linux/string.h>
#include <linux/configfs.h>
#include <linux/ctype.h>
#include <asm/unaligned.h>
#include <scsi/scsi.h>
#include <scsi/scsi_host.h>
#include <scsi/scsi_device.h>
#include <scsi/scsi_cmnd.h>
#include <scsi/libfc.h>

#include <target/target_core_base.h>
#include <target/target_core_transport.h>
#include <target/target_core_fabric_ops.h>
#include <target/target_core_device.h>
#include <target/target_core_tpg.h>
#include <target/target_core_configfs.h>
#include <target/target_core_alua.h>
#include <target/target_core_base.h>
#include <target/target_core_seobj.h>
#include <target/configfs_macros.h>

#include "tcm_fc.h"

struct target_fabric_configfs *ft_configfs;

LIST_HEAD(ft_lport_list);
DEFINE_MUTEX(ft_lport_lock);

unsigned int ft_debug_logging;
module_param_named(debug_logging, ft_debug_logging, int, S_IRUGO|S_IWUSR);
MODULE_PARM_DESC(debug_logging, "a bit mask of logging levels");

/*
 * Configfs infrastructure, possibly.
 */
struct ft_attr {
	struct configfs_attribute attr;
	u32	offset;		/* offset of attribute value in parent struct */
	void *(*obj_from_item)(struct config_item *);
	ssize_t	(*show)(void *, char *);
	ssize_t	(*store)(void *, const char *, size_t);
};

static ssize_t ft_show_item(struct config_item *item,
			    struct configfs_attribute *attr, char *buf)
{
	struct ft_attr *ft_attr;
	void *ptr;

	ft_attr = container_of(attr, struct ft_attr, attr);
	ptr = ft_attr->obj_from_item(item) + ft_attr->offset;
	return ft_attr->show(ptr, buf);
}

static ssize_t ft_store_item(struct config_item *item,
			     struct configfs_attribute *attr,
			     const char *buf, size_t len)
{
	struct ft_attr *ft_attr;
	void *ptr;

	ft_attr = container_of(attr, struct ft_attr, attr);
	ptr = ft_attr->obj_from_item(item) + ft_attr->offset;
	return ft_attr->store(ptr, buf, len);
}

static struct configfs_item_operations ft_item_ops = {
	.show_attribute = ft_show_item,
	.store_attribute = ft_store_item,
};

#define FT_ATTR(_name, _type, _field, _mode, _find, _show, _store)	\
	{								\
		.attr = {						\
			.ca_name = (_name),				\
			.ca_mode = (_mode),				\
			.ca_owner = THIS_MODULE,			\
		},							\
		.offset = offsetof(struct _type, _field),		\
		.obj_from_item = (_find),				\
		.show = (_show),					\
		.store = (_store),					\
	}

/*
 * Parse WWN.
 * If strict, we require lower-case hex and colon separators to be sure
 * the name is the same as what would be generated by ft_format_wwn()
 * so the name and wwn are mapped one-to-one.
 */
static ssize_t ft_parse_wwn(const char *name, u64 *wwn, int strict)
{
	const char *cp;
	char c;
	u32 nibble;
	u32 byte = 0;
	u32 pos = 0;
	u32 err;

	*wwn = 0;
	for (cp = name; cp < &name[FT_NAMELEN - 1]; cp++) {
		c = *cp;
		if (c == '\n' && cp[1] == '\0')
			continue;
		if (strict && pos++ == 2 && byte++ < 7) {
			pos = 0;
			if (c == ':')
				continue;
			err = 1;
			goto fail;
		}
		if (c == '\0') {
			err = 2;
			if (strict && byte != 8)
				goto fail;
			return cp - name;
		}
		err = 3;
		if (isdigit(c))
			nibble = c - '0';
		else if (isxdigit(c) && (islower(c) || !strict))
			nibble = tolower(c) - 'a' + 10;
		else
			goto fail;
		*wwn = (*wwn << 4) | nibble;
	}
	err = 4;
fail:
	FT_CONF_DBG("err %u len %zu pos %u byte %u\n",
		    err, cp - name, pos, byte);
	return -1;
}

ssize_t ft_format_wwn(char *buf, size_t len, u64 wwn)
{
	u8 b[8];

	put_unaligned_be64(wwn, b);
	return snprintf(buf, len,
		 "%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x",
		 b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
}

static ssize_t ft_wwn_show(void *arg, char *buf)
{
	u64 *wwn = arg;
	ssize_t len;

	len = ft_format_wwn(buf, PAGE_SIZE - 2, *wwn);
	buf[len++] = '\n';
	return len;
}

static ssize_t ft_wwn_store(void *arg, const char *buf, size_t len)
{
	ssize_t ret;
	u64 wwn;

	ret = ft_parse_wwn(buf, &wwn, 0);
	if (ret > 0)
		*(u64 *)arg = wwn;
	return ret;
}

/*
 * Target port LUN port ops.
 */

static struct ft_tpg *ft_tpg_from_lun_ci(struct config_item *lun_ci)
{
	struct config_item *tpg_ci;
	struct se_portal_group_s *se_tpg;

	tpg_ci = &lun_ci->ci_parent->ci_group->cg_item;
	se_tpg = container_of(to_config_group(tpg_ci),
			      struct se_portal_group_s, tpg_group);
	return se_tpg->se_tpg_fabric_ptr;
}

/*
 * For ALUA Target port attributes for port LUN
 */
CONFIGFS_EATTR_STRUCT(ft_lun_port, se_lun_s);
#define FT_PORT_ATTR(_name, _mode)					\
static struct ft_lun_port_attribute ft_lun_port_##_name =		\
	__CONFIGFS_EATTR(_name, _mode,					\
	ft_lun_port_show_attr_##_name,					\
	ft_lun_port_store_attr_##_name);

/*
 * alua_tg_pt_gp
 */
static ssize_t ft_lun_port_show_attr_alua_tg_pt_gp(
	struct se_lun_s *lun,
	char *page)
{
	if (!(lun->lun_sep))
		return -ENODEV;
	
	return core_alua_show_tg_pt_gp_info(lun->lun_sep, page);
}

static ssize_t ft_lun_port_store_attr_alua_tg_pt_gp(
	struct se_lun_s *lun,
	const char *page,
	size_t count)
{
	if (!(lun->lun_sep))
		return -ENODEV;

	return core_alua_store_tg_pt_gp_info(lun->lun_sep, page, count);
}

FT_PORT_ATTR(alua_tg_pt_gp, S_IRUGO | S_IWUSR);

/*
 * alua_tg_pt_offline
 */
static ssize_t ft_lun_port_show_attr_alua_tg_pt_offline(
	struct se_lun_s *lun,
	char *page)
{
	if (!(lun->lun_sep))
		return -ENODEV;

	return core_alua_show_offline_bit(lun, page);
}

static ssize_t ft_lun_port_store_attr_alua_tg_pt_offline(
	struct se_lun_s *lun,
	const char *page,
	size_t count)
{
	if (!(lun->lun_sep))
		return -ENODEV;

	return core_alua_store_offline_bit(lun, page, count);
}

FT_PORT_ATTR(alua_tg_pt_offline, S_IRUGO | S_IWUSR);

/*
 * alua_tg_pt_status
 */
static ssize_t ft_lun_port_show_attr_alua_tg_pt_status(
	struct se_lun_s *lun,
	char *page)
{
	if (!(lun->lun_sep))
		return -ENODEV;

	return core_alua_show_secondary_status(lun, page);
}

static ssize_t ft_lun_port_store_attr_alua_tg_pt_status(
	struct se_lun_s *lun,
	const char *page,
	size_t count)
{
	if (!(lun->lun_sep))
		return -ENODEV;

	return core_alua_store_secondary_status(lun, page, count);
}

FT_PORT_ATTR(alua_tg_pt_status, S_IRUGO | S_IWUSR);

/*
 * alua_tg_pt_write_md
 */
static ssize_t ft_lun_port_show_attr_alua_tg_pt_write_md(
	struct se_lun_s *lun,
	char *page)
{
	if (!(lun->lun_sep))
		return -ENODEV;

	return core_alua_show_secondary_write_metadata(lun, page);
}

static ssize_t ft_lun_port_store_attr_alua_tg_pt_write_md(
	struct se_lun_s *lun,
	const char *page,
	size_t count)
{
	if (!(lun->lun_sep))
		return -ENODEV;

	return core_alua_store_secondary_write_metadata(lun, page, count);
}

FT_PORT_ATTR(alua_tg_pt_write_md, S_IRUGO | S_IWUSR);

static struct configfs_attribute *ft_lun_port_attrs[] = {
	&ft_lun_port_alua_tg_pt_gp.attr,
	&ft_lun_port_alua_tg_pt_offline.attr,
	&ft_lun_port_alua_tg_pt_status.attr,
	&ft_lun_port_alua_tg_pt_write_md.attr,
	NULL,
};

CONFIGFS_EATTR_OPS(ft_lun_port, se_lun_s, lun_group);

static int ft_lun_port_link(struct config_item *lun_ci,
			    struct config_item *se_dev_ci)
{
	struct ft_tpg *tpg;
	se_device_t *dev;
	se_lun_t *lun = container_of(to_config_group(lun_ci),
				se_lun_t, lun_group);
	se_lun_t *lun_p;
	se_subsystem_dev_t *se_dev = container_of(
		to_config_group(se_dev_ci), se_subsystem_dev_t, se_dev_group);

	if (lun->lun_type_ptr != NULL) {
		FT_CONF_DBG("Port Symlink already exists\n");
		return -EEXIST;
	}

	tpg = ft_tpg_from_lun_ci(lun_ci);
	if (!tpg)
		return -EINVAL;

	dev = se_dev->se_dev_ptr;
	if (!dev) {
		FT_CONF_DBG("Unable to locate se_device_t pointer from %s\n",
			    config_item_name(se_dev_ci));
		return -ENODEV;
	}

	lun_p = core_dev_add_lun(tpg->se_tpg, dev->se_hba, dev,
				 lun->unpacked_lun);
	if (IS_ERR(lun_p) || !lun_p) {
		FT_CONF_DBG("core_dev_add_lun() failed: %ld\n", PTR_ERR(lun_p));
		return -EINVAL;
	}

	FT_CONF_DBG("Created Port Symlink %s -> %s\n",
		    config_item_name(se_dev_ci), config_item_name(lun_ci));
	return 0;
}

static int ft_lun_port_check_link(struct config_item *lun_ci,
				  struct config_item *se_dev_ci)
{
	se_lun_t *lun = container_of(to_config_group(lun_ci),
			se_lun_t, lun_group);

	return atomic_read(&lun->lun_acl_count) ? -EPERM : 0;
}

static int ft_lun_port_unlink(struct config_item *lun_ci,
			      struct config_item *se_dev_ci)
{
	struct ft_tpg *tpg;
	se_lun_t *lun = container_of(to_config_group(lun_ci),
			se_lun_t, lun_group);
	int ret;

	tpg = ft_tpg_from_lun_ci(lun_ci);
	if (!tpg)
		return -EINVAL;

	ret = core_dev_del_lun(tpg->se_tpg, lun->unpacked_lun);

	FT_CONF_DBG("Removed Port Symlink %s -> %s\n",
		config_item_name(se_dev_ci), config_item_name(lun_ci));
	return ret;
}

static struct configfs_item_operations ft_lun_port_item_ops = {
	.show_attribute = ft_lun_port_attr_show,
	.store_attribute = ft_lun_port_attr_store,
	.allow_link = ft_lun_port_link,
	.check_link = ft_lun_port_check_link,
	.drop_link = ft_lun_port_unlink,
};

static struct config_item_type ft_lun_port_cit = {
	.ct_item_ops = &ft_lun_port_item_ops,
	.ct_attrs = ft_lun_port_attrs,
	.ct_owner = THIS_MODULE,
};

/*
 * LUN ops.
 */

static struct config_group *ft_add_lun(struct config_group *group,
				       const char *name)
{
	struct se_lun_s *lun;
	struct ft_tpg *tpg;
	unsigned long index;

	FT_CONF_DBG("add lun %s\n", name);

	/*
	 * Name must be "lun_" followed by the index.
	 */
	if (strstr(name, "lun_") != name)
		return NULL;

	if (strict_strtoul(name + 4, 10, &index) || index > UINT_MAX)
		return NULL;

	tpg = container_of(group, struct ft_tpg, lun_group);
	lun = core_get_lun_from_tpg(tpg->se_tpg, index);
	if (!lun)
		return NULL;
	config_group_init_type_name(&lun->lun_group, name, &ft_lun_port_cit);
	return &lun->lun_group;
}

static void ft_del_lun(struct config_group *group, struct config_item *item)
{
	FT_CONF_DBG("del lun %s p %p\n", config_item_name(item), item);
	config_item_put(item);
}

static struct configfs_group_operations ft_lun_group_ops = {
	.make_group = ft_add_lun,
	.drop_item = ft_del_lun,
};

static struct config_item_type ft_lun_cit = {
	.ct_group_ops = &ft_lun_group_ops,
	.ct_owner = THIS_MODULE,
};

/*
 * LUN ACL item ops.
 */

static int ft_lun_acl_link(struct config_item *lun_acl_ci,
			   struct config_item *lun_ci)
{
	struct se_node_acl_s *se_nacl;
	struct se_lun_s *lun;
	struct se_portal_group_s *se_tpg;
	struct se_dev_entry_s *deve;
	struct config_item *item;
	struct config_group *tpg_group;
	struct ft_lun_acl_group *ft_lun_acl;
	int lun_access;
	int ret;

	FT_CONF_DBG("links %s to %s\n",
		    config_item_name(lun_acl_ci), config_item_name(lun_ci));

	/*
	 * Make sure parent of lun_ci is same TPG as parent of lun_acl_ci.
	 * lun_acl_ci is fc/<tpg>/acl/<wwpn>/lun_<x>
	 * lun_ci     is fc/<tpg>/lun/lun_<y>
	 * tpg should be equal.
	 */
	item = lun_acl_ci->ci_parent;	/* node acl <wwpn> */
	item = item->ci_parent;		/* "acl" */
	tpg_group = item->ci_group;	/* <tpg> */
	item = lun_ci->ci_parent;	/* "lun" */
	if (!item)
		return -EINVAL;

	FT_CONF_DBG("tpg_group %s to lun_tpg %s\n",
		    config_item_name(&tpg_group->cg_item),
		    config_item_name(&item->ci_group->cg_item));

	if (tpg_group != item->ci_group) {
		FT_CONF_DBG("links not in same tpg\n");
		return -EINVAL;
	}

	ft_lun_acl = container_of(to_config_group(lun_acl_ci),
				   struct ft_lun_acl_group, group);

	lun = container_of(to_config_group(lun_ci), se_lun_t, lun_group);

	se_tpg = container_of(tpg_group, struct se_portal_group_s, tpg_group);

	se_nacl = ft_lun_acl->lun_acl->se_lun_nacl;
	spin_lock_bh(&se_nacl->device_list_lock);
	deve = &se_nacl->device_list[ft_lun_acl->lun_acl->mapped_lun];
	if (deve->lun_flags & TRANSPORT_LUNFLAGS_INITIATOR_ACCESS)
		lun_access = deve->lun_flags;
	else
		lun_access = TRANSPORT_LUNFLAGS_READ_WRITE;	/* XXX */
	spin_unlock_bh(&se_nacl->device_list_lock);

	ret = core_dev_add_initiator_node_lun_acl(se_tpg, ft_lun_acl->lun_acl,
			lun->unpacked_lun, lun_access);
	if (ret < 0) {
		FT_CONF_DBG("link %s to %s ret %d\n",
			config_item_name(lun_acl_ci),
			config_item_name(lun_ci), ret);
		return ret;
	}
	return 0;
}

static int ft_lun_acl_unlink(struct config_item *lun_acl_ci,
			     struct config_item *lun_ci)
{
	struct se_lun_s *lun;
	struct se_portal_group_s *se_tpg;
	struct config_group *tpg_group;
	struct ft_lun_acl_group *ft_lun_acl;
	int ret;

	FT_CONF_DBG("unlink %s and %s\n",
		    config_item_name(lun_acl_ci),
		    config_item_name(lun_ci));
	/*
	 * lun_acl_ci is fc/<tpg>/acl/<wwpn>/lun_<x>
	 * lun_ci     is fc/<tpg>/lun/lun_<y>
	 */
	tpg_group = lun_acl_ci->ci_parent->ci_parent->ci_group;

	FT_CONF_DBG("tpg_group %s delete lun_acl %s\n",
		    config_item_name(&tpg_group->cg_item),
		    config_item_name(lun_acl_ci));

	ft_lun_acl = container_of(to_config_group(lun_acl_ci),
				   struct ft_lun_acl_group, group);
	lun = container_of(to_config_group(lun_ci), se_lun_t, lun_group);

	se_tpg = container_of(tpg_group, struct se_portal_group_s, tpg_group);

	ret = core_dev_del_initiator_node_lun_acl(se_tpg, lun,
						  ft_lun_acl->lun_acl);
	if (ret < 0) {
		FT_CONF_DBG("link %s to %s ret %d\n",
			    config_item_name(lun_acl_ci),
			    config_item_name(lun_ci), ret);
		return ret;
	}
	return 0;
}

static void ft_lun_acl_release(struct config_item *item)
{
	kfree(container_of(to_config_group(item),
			   struct ft_lun_acl_group, group));
}

static struct configfs_item_operations ft_lun_acl_item_ops = {
	.release =	ft_lun_acl_release,
	.allow_link =	ft_lun_acl_link,
	.drop_link =	ft_lun_acl_unlink,
};

static struct config_item_type ft_lun_acl_cit = {
	.ct_item_ops =	&ft_lun_acl_item_ops,
	.ct_attrs = NULL,
	.ct_owner = THIS_MODULE,
};

/*
 * LUN ACL group ops.
 */

static struct config_group *ft_add_lun_acl(struct config_group *group,
					   const char *name)
{
	struct se_lun_acl_s *lun_acl;
	struct ft_tpg *tpg;
	struct ft_node_acl *acl;
	unsigned long index;
	struct ft_lun_acl_group *ft_lun_acl;
	int ret;

	FT_CONF_DBG("add lun acl %s\n", name);

	/*
	 * Name must be "lun_" followed by the index.
	 */
	if (strstr(name, "lun_") != name)
		return NULL;

	if (strict_strtoul(name + 4, 10, &index) || index > UINT_MAX)
		return NULL;

	acl = container_of(group, struct ft_node_acl, group);
	tpg = container_of(acl->group.cg_item.ci_group,
			   struct ft_tpg, acl_group);

	FT_CONF_DBG("add lun acl %s init name %s\n", name,
		    config_item_name(&acl->group.cg_item));

	ft_lun_acl = kzalloc(sizeof(*ft_lun_acl), GFP_KERNEL);
	if (!ft_lun_acl)
		return NULL;

	lun_acl = core_dev_init_initiator_node_lun_acl(tpg->se_tpg, index,
			config_item_name(&acl->group.cg_item), &ret);
	if (!lun_acl) {
		kfree(ft_lun_acl);
		return NULL;
	}
	ft_lun_acl->lun_acl = lun_acl;

	config_group_init_type_name(&ft_lun_acl->group, name,
				    &ft_lun_acl_cit);
	return &ft_lun_acl->group;
}

static void ft_del_lun_acl(struct config_group *group,
			   struct config_item *item)
{
	struct ft_node_acl *acl;
	struct ft_tpg *tpg;
	struct ft_lun_acl_group *ft_lun_acl;

	FT_CONF_DBG("del lun acl %s p %p\n", config_item_name(item), item);

	acl = container_of(group, struct ft_node_acl, group);
	tpg = container_of(acl->group.cg_item.ci_group,
			   struct ft_tpg, acl_group);
	ft_lun_acl = container_of(to_config_group(item),
				  struct ft_lun_acl_group, group);
	FT_CONF_DBG("del lun acl. tpg %u\n", tpg->index);

	core_dev_free_initiator_node_lun_acl(tpg->se_tpg, ft_lun_acl->lun_acl);
	config_item_put(item);
}

static struct configfs_group_operations ft_lun_acl_group_ops = {
	.make_group = ft_add_lun_acl,
	.drop_item = ft_del_lun_acl,
};

/*
 * ACL auth ops.
 */

static void *ft_acl_from_auth(struct config_item *item)
{
	return container_of(item->ci_group, struct ft_node_acl, group);
}

static struct ft_attr ft_acl_port_name_attr =
		FT_ATTR("port_name", ft_node_acl, node_auth.port_name,
				S_IRUGO, ft_acl_from_auth,
				ft_wwn_show, ft_wwn_store);

static struct ft_attr ft_acl_node_name_attr =
		FT_ATTR("node_name", ft_node_acl, node_auth.node_name,
				S_IRUGO | S_IWUSR, ft_acl_from_auth,
				ft_wwn_show, ft_wwn_store);

static struct configfs_attribute *ft_nacl_auth_attrs[] = {
	&ft_acl_port_name_attr.attr,
	&ft_acl_node_name_attr.attr,
	NULL,
};

static void ft_acl_release(struct config_item *item)
{
	kfree(container_of(item, struct ft_node_acl, group.cg_item));
}

static struct configfs_item_operations ft_acl_item_ops = {
	.release = ft_acl_release,
};

static struct config_item_type ft_nacl_auth_cit = {
	.ct_item_ops = &ft_item_ops,
	.ct_attrs = ft_nacl_auth_attrs,
	.ct_owner = THIS_MODULE,
};

static struct config_item_type ft_nacl_cit = {
	.ct_item_ops = &ft_acl_item_ops,
	.ct_group_ops = &ft_lun_acl_group_ops,
	.ct_owner = THIS_MODULE,
};

/*
 * ACL ops.
 */

/*
 * Add ACL for an initiator.  The ACL is named arbitrarily.
 * The port_name and/or node_name are attributes.
 */
static struct config_group *ft_add_acl(struct config_group *group,
				       const char *name)
{
	struct ft_node_acl *acl;
	struct se_node_acl_s *se_acl;
	struct config_group *new;
	struct ft_tpg *tpg;
	u64 wwpn;
	u32 q_depth;

	FT_CONF_DBG("add acl %s\n", name);
	tpg = container_of(group, struct ft_tpg, acl_group);

	if (ft_parse_wwn(name, &wwpn, 1) < 0)
		return NULL;

	q_depth = 32;		/* XXX bogus default - get from tpg? */
	se_acl = core_tpg_add_initiator_node_acl(tpg->se_tpg, name, q_depth);
	if (IS_ERR(se_acl) || !se_acl)
		return NULL;

	acl = se_acl->fabric_acl_ptr;
	acl->node_auth.port_name = wwpn;
	new = &acl->group;
	config_group_init_type_name(new, name, &ft_nacl_cit);
	config_group_init_type_name(&acl->auth_group, "auth",
				    &ft_nacl_auth_cit);
/* XXXX TBD add se_acl->param_group to groups */
	acl->groups[0] = &acl->auth_group;
	acl->groups[3] = NULL;
	new->default_groups = acl->groups;

	return new;
}

static void ft_del_acl(struct config_group *group, struct config_item *item)
{
	struct ft_tpg *tpg;
	struct ft_node_acl *acl;
	struct se_node_acl_s *se_acl;

	FT_CONF_DBG("del acl %s\n", config_item_name(item));

	tpg = container_of(group, struct ft_tpg, acl_group);
	acl = container_of(to_config_group(item), struct ft_node_acl, group);
	se_acl = acl->se_node_acl;

	FT_CONF_DBG("del acl %p se_acl %p tpg %p se_tpg %p\n",
		    acl, se_acl, tpg, tpg->se_tpg);

	core_tpg_del_initiator_node_acl(tpg->se_tpg, se_acl, 1);
	config_item_put(item);
}

struct ft_node_acl *ft_acl_get(struct ft_tpg *tpg, struct fc_rport_priv *rdata)
{
	struct ft_node_acl *found = NULL;
	struct ft_node_acl *acl;
	struct se_portal_group_s *se_tpg;
	struct se_node_acl_s *se_acl;

	se_tpg = tpg->se_tpg;
	if (!se_tpg) {
		FT_CONF_DBG("tpg %p se_tpg NULL\n", tpg);
		return NULL;
	}
	spin_lock_bh(&se_tpg->acl_node_lock);
	list_for_each_entry(se_acl, &se_tpg->acl_node_list, acl_list) {
		acl = se_acl->fabric_acl_ptr;
		FT_CONF_DBG("acl %p port_name %llx\n",
			acl, (unsigned long long)acl->node_auth.port_name);
		if (acl->node_auth.port_name == rdata->ids.port_name ||
		    acl->node_auth.node_name == rdata->ids.node_name) {
			FT_CONF_DBG("acl %p port_name %llx matched\n", acl,
				    (unsigned long long)rdata->ids.port_name);
			found = acl;
			/* XXX need to hold onto ACL */
			break;
		}
	}
	spin_unlock_bh(&se_tpg->acl_node_lock);
	return found;
}

static void *ft_tpg_alloc_fabric_acl(se_portal_group_t *se_tpg,
				     se_node_acl_t *se_nacl)
{
	struct ft_node_acl *acl;

	acl = kzalloc(sizeof(*acl), GFP_KERNEL);
	if (acl)
		acl->se_node_acl = se_nacl;
	FT_CONF_DBG("acl %p\n", acl);
	return acl;
}

static void ft_tpg_release_fabric_acl(se_portal_group_t *se_tpg,
				      se_node_acl_t *se_acl)
{
	struct ft_node_acl *acl = se_acl->fabric_acl_ptr;

	FT_CONF_DBG(KERN_INFO "acl %p\n", acl);
	/* freed after put item in del_acl now */
}

static struct configfs_group_operations ft_acl_group_ops = {
	.make_group = ft_add_acl,
	.drop_item = ft_del_acl,
};

static struct config_item_type ft_acl_cit = {
	.ct_group_ops = &ft_acl_group_ops,
	.ct_owner = THIS_MODULE,
};

/*
 * Target port group ops.
 * Nothing for now - add enable/disable to protect during setup, eventually.
 */
static struct config_item_type ft_tpg_cit = {
	.ct_owner = THIS_MODULE,
};

/*
 * local_port port_group (tpg) ops.
 */
static struct config_group *ft_add_tpg(struct config_group *group,
				       const char *name)
{
	struct ft_lport_acl *lacl;
	struct ft_tpg *tpg;
	struct se_portal_group_s *se_tpg;
	struct config_group *tpg_cg;
	unsigned long index;

	FT_CONF_DBG("tcm_fc: add tpg %s\n", name);

	/*
	 * Name must be "tpgt_" followed by the index.
	 */
	if (strstr(name, "tpgt_") != name)
		return NULL;
	if (strict_strtoul(name + 5, 10, &index) || index > UINT_MAX)
		return NULL;

	lacl = container_of(group, struct ft_lport_acl, group);
	tpg = kzalloc(sizeof(*tpg), GFP_KERNEL);
	if (!tpg)
		return NULL;
	tpg->index = index;
	tpg->lport_acl = lacl;
	INIT_LIST_HEAD(&tpg->lun_list);
	transport_init_queue_obj(&tpg->qobj);

	se_tpg = core_tpg_register(&ft_configfs->tf_ops, tpg,
					TRANSPORT_TPG_TYPE_NORMAL);
	if (IS_ERR(se_tpg)) {
		kfree(tpg);
		return NULL;
	}
	tpg->se_tpg = se_tpg;
	se_tpg->se_tpg_fabric_ptr = tpg;

	tpg->thread = kthread_run(ft_thread, tpg, "ft_tpg%lu", index);
	if (IS_ERR(tpg->thread)) {
		core_tpg_deregister(se_tpg);
		kfree(tpg);
		return NULL;
	}
	wait_for_completion(&tpg->qobj.thread_create_comp);

	mutex_lock(&ft_lport_lock);
	list_add_tail(&tpg->list, &lacl->tpg_list);
	mutex_unlock(&ft_lport_lock);

	tpg_cg = &se_tpg->tpg_group;
	tpg_cg->default_groups = tpg->groups;
	config_group_init_type_name(&tpg->lun_group, "lun", &ft_lun_cit);
	config_group_init_type_name(&tpg->acl_group, "acl", &ft_acl_cit);
	tpg->groups[0] = &tpg->lun_group;
	tpg->groups[1] = &tpg->acl_group;
	tpg->groups[2] = NULL;

	config_group_init_type_name(tpg_cg, name, &ft_tpg_cit);
	return tpg_cg;
}

static void ft_del_tpg(struct config_group *group, struct config_item *item)
{
	struct se_portal_group_s *se_tpg;
	struct ft_tpg *tpg;

	FT_CONF_DBG("del tpg %s\n", config_item_name(item));
	se_tpg = container_of(to_config_group(item), se_portal_group_t,
			      tpg_group);
	tpg = se_tpg->se_tpg_fabric_ptr;
	kthread_stop(tpg->thread);
	wait_for_completion(&tpg->qobj.thread_done_comp);

	/* Wait for sessions to be freed thru RCU, for BUG_ON below */
	synchronize_rcu();

	mutex_lock(&ft_lport_lock);
	list_del(&tpg->list);
	if (tpg->tport) {
		tpg->tport->tpg = NULL;
		tpg->tport = NULL;
	}
	mutex_unlock(&ft_lport_lock);

	config_item_put(item);
	kfree(tpg);
}

/*
 * Verify that an lport is configured to use the tcm_fc module, and return
 * the target port group that should be used.
 *
 * The caller holds ft_lport_lock.
 */
struct ft_tpg *ft_lport_find_tpg(struct fc_lport *lport)
{
	struct ft_lport_acl *lacl;
	struct ft_tpg *tpg;

	list_for_each_entry(lacl, &ft_lport_list, list) {
		if (lacl->wwpn == lport->wwpn) {
			list_for_each_entry(tpg, &lacl->tpg_list, list)
				return tpg; /* XXX for now return first entry */
			return NULL;
		}
	}
	return NULL;
}

static void ft_free_lport(struct config_item *item)
{
	kfree(container_of(item, struct ft_lport_acl, group.cg_item));
}

static struct configfs_item_operations ft_lport_item_ops = {
	.release = ft_free_lport,
};

static struct configfs_group_operations ft_lport_group_ops = {
	.make_group = ft_add_tpg,
	.drop_item = ft_del_tpg,
};

static struct config_item_type ft_lport_cit = {
	.ct_item_ops = &ft_lport_item_ops,
	.ct_group_ops = &ft_lport_group_ops,
	.ct_owner = THIS_MODULE,
};

/*
 * target config instance ops.
 */

/*
 * Add lport to allowed config.
 * The name is the WWPN in lower-case ASCII, colon-separated bytes.
 */
static struct config_group *ft_add_lport(struct config_group *group,
					 const char *name)
{
	struct ft_lport_acl *lacl;
	struct ft_lport_acl *old_lacl;
	u64 wwpn;

	FT_CONF_DBG("add lport %s\n", name);
	if (ft_parse_wwn(name, &wwpn, 1) < 0)
		return NULL;
	lacl = kzalloc(sizeof(*lacl), GFP_KERNEL);
	if (!lacl)
		return NULL;
	lacl->wwpn = wwpn;
	INIT_LIST_HEAD(&lacl->tpg_list);

	mutex_lock(&ft_lport_lock);
	list_for_each_entry(old_lacl, &ft_lport_list, list) {
		if (old_lacl->wwpn == wwpn) {
			mutex_unlock(&ft_lport_lock);
			kfree(lacl);
			return NULL;
		}
	}
	list_add_tail(&lacl->list, &ft_lport_list);
	ft_format_wwn(lacl->name, sizeof(lacl->name), wwpn);
	mutex_unlock(&ft_lport_lock);
	config_group_init_type_name(&lacl->group, lacl->name,
				    &ft_lport_cit);
	return &lacl->group;
}

static void ft_del_lport(struct config_group *group, struct config_item *item)
{
	struct ft_lport_acl *lacl = container_of(to_config_group(item),
						struct ft_lport_acl, group);

	FT_CONF_DBG("del lport %s\n", config_item_name(item));
	mutex_lock(&ft_lport_lock);
	list_del(&lacl->list);
	mutex_unlock(&ft_lport_lock);
	config_item_put(item);
}

static struct configfs_group_operations ft_group_ops = {
	.make_group = ft_add_lport,
	.drop_item = ft_del_lport,
};

static ssize_t ft_version_show(struct config_item *item,
			       struct configfs_attribute *attr, char *page)
{
	return sprintf(page, "TCM FC " FT_VERSION "\n");
}

static struct configfs_item_operations ft_item_attr_version_ops = {
	.show_attribute = ft_version_show,
};

static struct configfs_attribute ft_item_attr_version = {
	.ca_owner = THIS_MODULE,
	.ca_name = "version",
	.ca_mode = S_IRUGO,
};

static struct configfs_attribute *ft_attrs[] = {
	&ft_item_attr_version,
	NULL,
};

static struct config_item_type ft_cit = {
	.ct_item_ops = &ft_item_attr_version_ops,
	.ct_group_ops = &ft_group_ops,
	.ct_attrs = ft_attrs,
	.ct_owner = THIS_MODULE,
};

static char *ft_get_fabric_name(void)
{
	return "fc";
}

static u8 ft_get_fabric_proto_ident(void)
{
	return 0;	/* 0 = fcp-2 per SPC4 section 7.5.1 */
}

static char *ft_get_fabric_wwn(se_portal_group_t *se_tpg)
{
	struct ft_tpg *tpg = se_tpg->se_tpg_fabric_ptr;

	return tpg->lport_acl->name;
}

static u16 ft_get_tag(se_portal_group_t *se_tpg)
{
	struct ft_tpg *tpg = se_tpg->se_tpg_fabric_ptr;

	/*
	 * This tag is used when forming SCSI Name identifier in EVPD=1 0x83
	 * to represent the SCSI Target Port.
	 */
	return tpg->index;
}

static u32 ft_get_default_depth(se_portal_group_t *se_tpg)
{
	return 1;
}

static u32 ft_get_pr_transport_id_len(se_portal_group_t *se_tpg,
				      se_node_acl_t *se_nacl, int *format_code)
{
	*format_code = 0;
	return sizeof(struct ft_transport_id);
}

static u32 ft_get_pr_transport_id(se_portal_group_t *se_tpg,
				  se_node_acl_t *se_nacl,
				  int *format_code, unsigned char *buf)
{
	se_session_t *se_sess;
	struct ft_sess *sess;
	struct ft_transport_id *id = (struct ft_transport_id *)buf;

	memset(id, 0, sizeof(*id));
	spin_lock(&se_nacl->nacl_sess_lock);
	se_sess = se_nacl->nacl_sess;
	if (se_sess) {
		sess = se_sess->fabric_sess_ptr;
		if (sess)
			put_unaligned_be64(sess->port_name, id->wwpn);
	}
	spin_unlock(&se_nacl->nacl_sess_lock);
	return ft_get_pr_transport_id_len(se_tpg, se_nacl, format_code);
}

static char *ft_parse_pr_out_transport_id(const char *buf, u32 *out_tid_len,
					  char **port_nexus_ptr)
{
	struct ft_transport_id *id = (struct ft_transport_id *)buf;

	*port_nexus_ptr = NULL;
	*out_tid_len = sizeof(*id);
	return (char *)&id->wwpn;

	/* XXX may be a problem with the caller expecting ASCII */
}

static int ft_check_false(se_portal_group_t *se_tpg)
{
	return 0;
}

static void ft_set_default_node_attr(se_node_acl_t *se_nacl)
{
}

static u16 ft_get_fabric_sense_len(void)
{
	return 0;
}

static u16 ft_set_fabric_sense_len(struct se_cmd_s *se_cmd, u32 sense_len)
{
	return 0;
}

static u32 ft_tpg_get_inst_index(struct se_portal_group_s *se_tpg)
{
	struct ft_tpg *tpg = se_tpg->se_tpg_fabric_ptr;

	return tpg->index;
}

static u64 ft_pack_lun(unsigned int index)
{
	WARN_ON(index >= 256);
	/* Caller wants this byte-swapped */
	return cpu_to_le64((index & 0xff) << 8);
}

static struct target_core_fabric_ops ft_fabric_ops = {
	.get_fabric_name =		ft_get_fabric_name,
	.get_fabric_proto_ident =	ft_get_fabric_proto_ident,
	.tpg_get_wwn =			ft_get_fabric_wwn,
	.tpg_get_tag =			ft_get_tag,
	.tpg_get_default_depth =	ft_get_default_depth,
	.tpg_get_pr_transport_id =	ft_get_pr_transport_id,
	.tpg_get_pr_transport_id_len =	ft_get_pr_transport_id_len,
	.tpg_parse_pr_out_transport_id = ft_parse_pr_out_transport_id,
	.tpg_check_demo_mode =		ft_check_false,
	.tpg_check_demo_mode_cache =	ft_check_false,
	.tpg_check_demo_mode_write_protect = ft_check_false,
	.tpg_alloc_fabric_acl =		ft_tpg_alloc_fabric_acl,
	.tpg_release_fabric_acl =	ft_tpg_release_fabric_acl,
#ifdef SNMP_SUPPORT
	.tpg_get_inst_index = 		ft_tpg_get_inst_index,
#endif /* SNMP_SUPPORT */
	.release_cmd_to_pool =		ft_release_cmd,
	.release_cmd_direct =		ft_release_cmd,
	.shutdown_session = 		ft_sess_shutdown,
	.close_session = 		ft_sess_close,
	.stop_session =			ft_sess_stop,
	.fall_back_to_erl0 =		ft_sess_set_erl0,
	.sess_logged_in =		ft_sess_logged_in,
#ifdef SNMP_SUPPORT
	.sess_get_index =		ft_sess_get_index,
#endif /* SNMP_SUPPORT */
	.sess_get_initiator_wwn =	ft_sess_get_port_name,
	.write_pending =		ft_write_pending,
	.write_pending_status =		ft_write_pending_status,
	.set_default_node_attributes =	ft_set_default_node_attr,
	.get_task_tag =			ft_get_task_tag,
	.get_cmd_state =		ft_get_cmd_state,
	.new_cmd_failure =		ft_new_cmd_failure,
	.queue_data_in =		ft_queue_data_in,
	.queue_status =			ft_queue_status,
	.queue_tm_rsp =			ft_queue_tm_resp,
	.get_fabric_sense_len =		ft_get_fabric_sense_len,
	.set_fabric_sense_len =		ft_set_fabric_sense_len,
	.is_state_remove =		ft_is_state_remove,
	.pack_lun =			ft_pack_lun,
};

int ft_register_configfs(void)
{
	struct target_fabric_configfs *fabric;
	int ret;

	/*
	 * Register the top level struct config_item_type with TCM core
	 */
	fabric = target_fabric_configfs_init(&ft_cit, "fc");
	if (!fabric) {
		printk(KERN_INFO "%s: target_fabric_configfs_init() failed!\n",
		       __func__);
		return -1;
	}
	fabric->tf_ops = ft_fabric_ops;

	/*
	 * register the fabric for use within TCM
	 */
	ret = target_fabric_configfs_register(fabric);
	if (ret < 0) {
		FT_CONF_DBG("target_fabric_configfs_register() for"
			    " FC Target failed!\n");
		printk(KERN_INFO
		       "%s: target_fabric_configfs_register() failed!\n",
		       __func__);
		target_fabric_configfs_free(fabric);
		return -1;
	}

	/*
	 * Setup our local pointer to *fabric.
	 */
	ft_configfs = fabric;
	return 0;
}

void ft_deregister_configfs(void)
{
	if (!ft_configfs)
		return;
	target_fabric_configfs_deregister(ft_configfs);
	ft_configfs = NULL;
}

static struct notifier_block ft_notifier = {
	.notifier_call = ft_lport_notify
};

static int __init ft_init(void)
{
	if (ft_register_configfs())
		return -1;
	if (fc_fc4_register_provider(FC_TYPE_FCP, &ft_prov)) {
		ft_deregister_configfs();
		return -1;
	}
	blocking_notifier_chain_register(&fc_lport_notifier_head, &ft_notifier);
	fc_lport_iterate(ft_lport_add, NULL);
	return 0;
}

static void __exit ft_exit(void)
{
	blocking_notifier_chain_unregister(&fc_lport_notifier_head,
					   &ft_notifier);
	fc_fc4_deregister_provider(FC_TYPE_FCP, &ft_prov);
	fc_lport_iterate(ft_lport_del, NULL);
	ft_deregister_configfs();
	synchronize_rcu();
}

#ifdef MODULE
MODULE_DESCRIPTION("FC TCM fabric driver " FT_VERSION);
MODULE_LICENSE("GPL");
module_init(ft_init);
module_exit(ft_exit);
#endif /* MODULE */
